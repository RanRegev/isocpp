## Default == is >, default < is < so

Document number: P0XXXX  
Date: 2016-05-15  
Audience: EWG  
Reply-to: Tony Van Eerd. order at forecode.com

## tl;dr:

```
class chair { ... };
```

We can all easily imagine what is in class `chair`.  It probably tells you the color, size, shape, material, number of legs, etc, of the chair. 
It would be unsurprising to want to compare two chairs for equality `ch1 == ch2` and determine that two chairs are, for salient properties, equal. 
In fact, when I learned C circa 1987, I tried to compare two structs for equality, and was saddened that it didn't work.  For this reason, I think that
default generation of == (and !=), a la P0221R1, is *great*, and *for most classes* both obvious and useful.

Now, what does it mean to ask "is this chair _less_ than that chair?" ?  I think this question has little to no meaning.
Is the chair smaller? Shorter? Less legs? Less _red_? (imagine that the first member of `chair` is colour in RGB format.)

`operator<()` on `chair` is _meaningless_.

I understand it _might_ be useful, in particular when used with `std::map` (but maybe you should use `unordered_map`?), etc.  But I don't appreciate meaningless API being added to ALL my classes.
Why not add a `calculate_volume` function that doesn't calculate the volume of the chair, or a `calculate_pi()` function, which doesn't calculate pi?
(Why not memberwise operator+ and divide by scalar? At least then I could  maybe calculate the _average chair_, which makes more sense than the _least chair_.)

## Ways Out

1. Make default generation of `operator<()` opt in.  This has been discussed in the past.  I'm not against it.
I'd still like `==` to be default-in, opt-out.  Because `==` almost always makes sense, `<` almost always doesn't.

2. Generate a default `std::order` (which would then be used by `std::map` et al).  `std::map` should never have defaulted to `std::less` it should have defaulted to some `std::order` (which could defer to std::less if/when std::order wasn't specialized).
An ordering is important and useful (it just shouldn't trump meaning, and should thus be separate from "less").  See Alisdair's P0181R0 for further work (on the library side) in a similar direction.

3. A new operator.  I know no one likes new syntax except the one proposing it, but...
For now, imagine it is "less-dot" ie `<.` because adding a dot seem to be in vogue
(even though, in this case `<.` would just lead to ambiguities like `.1 < .0`, as would `.<` and `.<.`)
The new operator could be generated by default, and called by `std::order` by default.
`std::less` could also call it (or std::order) whenever `<` is unavailable, to make things backwards compatible.
The better syntax would actually be `<>` (even though that means `!=` in some languages), because it can be read to mean "some order, not necessarily greater or less, but some order".

I recommend the new operator approach.

### Other uses

I think "less" and "representative order" are fundamentally different, and if we had both as independent concepts, we would find many natural uses.
The first use I found, years, ago, was  an `immutable_string` class. (Adobe, for example, had at least 2 classes like this.)
For `immutable_string`, all instances that are equal (by string equality) can share the same storage for the string. (Like copy-on-write, but you never write!)
The storage address becomes the implementation of `==`.
Address is also useful for implementing `<` when used in `std::map` (if/when lookup is more important than order).
But you still want `<` to be string-based less, for other uses, ie for display in a UI.
Separating "order" from "less", and `std::order` from `std::less` and `operator<>` from `operator<` solves these issues.

I think there are many other uses, waiting to be found.

## Take back std::less

I do know that there are many cases where a natural/meaningful `<` doesn't exist,
and many well-respected C++ leaders (eg Sean Parent, Alex Stepanov) recommend implementing `std::less` but not `operator<` in these cases.
This is a reasonable workaround, but it is still a workaround.
It also separates `std::less` from `operator<`, when the point of `std::less` was for it to be a function-object form of `operator<`.
It may also be prohibited by the standard (17.6.4.2.1 "only if the declaration depends on a user-defined type
and the specialization meets the standard library requirements for the original template"
- what are the requirements of `std::less`? - it is defined to return "x < y")

By separating "less" from "representation order", we can keep `std::less` as having the single meaning of "calls `x < y`"


## Acknowledgements

... TODO ...



