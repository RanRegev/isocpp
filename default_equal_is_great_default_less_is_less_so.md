## Default == is >, default < is < so

Document number: P0XXXX  
Date: 2016-05-15  
Audience: EWG  
Reply-to: Tony Van Eerd. order at forecode.com

## tl;dr:

```
class chair { ... };
```

What does `chair1 < chair2` _mean_?

We can all easily imagine what is in class `chair`.  It probably tells you the color, size, shape, material, number of legs, etc, of the chair. 
It would be unsurprising to want to compare two chairs for equality `chair1 == chair2` and determine that two chairs are, for salient properties, equal. 
In fact, when I learned C circa 1987, I tried to compare two structs for equality, and was saddened that it didn't work.  For this reason, I think that
default generation of == (and !=), a la P0221R1, is *great*, and *for most classes* both obvious and useful.

Now, what does it mean to ask "is this chair _less_ than that chair?" ?  I think this question has little to no meaning.
Is the chair smaller? Shorter? Less legs? Less _red_? (imagine that the first member of `chair` is colour in RGB format.)

`operator<()` on `chair` is _meaningless_.

I understand it _might_ be useful, in particular when used with `std::map` (but maybe you should use `unordered_map`?), etc.  But I don't appreciate meaningless API being added to ALL my classes.
Why not add a `calculate_volume` function that doesn't calculate the volume of the chair, or a `calculate_pi()` function, which doesn't calculate pi?
(Why not memberwise operator+ and divide by scalar? At least then I could  maybe calculate the _average chair_, which makes more sense than the _least chair_.)

## Ways Out

1. Make default generation of `operator<()` opt in.  This has been discussed in the past.  I'm not against it.
I'd still like `==` to be default-in, opt-out.  Because `==` almost always makes sense, `<` almost always doesn't.

2. Generate a default `std::order` (which would then be used by `std::map` et al).  `std::map` should never have defaulted to `std::less` it should have defaulted to some `std::order` (which could defer to `std::less` if/when `std::order` wasn't specialized).
An ordering is important and useful (but it shouldn't trump meaning, and should thus be separate from "less").  See Alisdair's P0181R0 for further work (on the library side) in a similar direction.

3. A new operator. The "ordering operator".  I know no one likes new syntax except the one proposing it, but...
For now, imagine it is `operator<>` (even though that means `!=` in some languages).*  It can be read to mean "some order, not necessarily greater or less, but some order". The new operator could be generated by default - _without ambiguity of meaning_, and called by `std::order`.  We could also have `std::less` call it (or `std::order`) whenever `<` is unavailable, to make things backwards compatible. 

I recommend the new operator approach.

### Other uses

I think "less" and "representative order" are fundamentally different, and if we had both as independent concepts, we would find many natural uses.
The first use I found, years, ago, was  an `immutable_string` class. (Adobe, for example, had at least 2 classes like this.)
For `immutable_string`, all instances that are equal (by string equality) can share the same storage for the string. (Like copy-on-write, but you never write!)
The storage address becomes the implementation of `==`.
Address is also useful for implementing `<` when used in `std::map` (if/when lookup is more important than order).
But you still want `<` to be string-based less, for other uses, ie for display in a UI.
Separating "order" from "less", and `std::order` from `std::less` and `operator<>` from `operator<` solves these issues.

I think there are many other uses, waiting to be found. I do know that there are enough cases where a natural/meaningful `<` doesn't exist,
that many well-respected C++ leaders (eg Sean Parent, Alex Stepanov) recommend implementing `std::less` but not `operator<` in these cases. To separate "order" from "less".  So cases exists, and work-arounds are currently in use.


## Take back std::less

Separating `std::less` from `operator<` is a reasonable work-around, but it is still a work-around.
The point of `std::less` was for it to be a function-object form of `operator<`; it is the  use of `std::less` in `std::map` et al that perverts the meaning of `std::less`.
(Note that these specializations of `std::less` may also be prohibited by the standard: 17.6.4.2.1 "only if the declaration depends on a user-defined type and the specialization meets the standard library requirements for the original template"
- what are the requirements of `std::less`? - it is defined to return "x < y")

By separating "less" from "representation order", we can keep `std::less` as having the single meaning of "calls `x < y`".  I would in fact go further, and deprecate any specializations of `std::less`.  It should only have one meaning.

## Conclusion(s)

1. Most importantly, please don't generate `operate<()` by default.  It is just wrong.
2. Please take some other path towards default ordering - one of the paths suggested above, or some other path, just not default generated `operator<()`.


## Acknowledgements

... TODO ...


## Footnotes

* It is tempting to suggest that the operator should be "less-dot" ie `<.` because adding a dot seem to be in vogue, but in this case `<.` would just lead to ambiguities like `.1 < .0`, as would `.<` and `.<.` :-)

